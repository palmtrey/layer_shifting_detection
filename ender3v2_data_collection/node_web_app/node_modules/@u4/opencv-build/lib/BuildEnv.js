"use strict";
var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
var _OpenCVBuildEnv_packageEnv, _OpenCVBuildEnv_ready, _OpenCVBuildEnv_enabledModules;
Object.defineProperty(exports, "__esModule", { value: true });
exports.OpenCVBuildEnv = exports.ALL_OPENCV_MODULES = exports.args2Option = exports.genHelp = exports.ALLARGS = exports.OPENCV_PATHS_ENV = void 0;
const fs_1 = __importDefault(require("fs"));
const os_1 = __importDefault(require("os"));
const path_1 = __importDefault(require("path"));
const npmlog_1 = __importDefault(require("npmlog"));
const utils_1 = require("./utils");
const crypto_1 = __importDefault(require("crypto"));
/**
 * list of variables needed to link and use openCV
 */
exports.OPENCV_PATHS_ENV = ['OPENCV_BIN_DIR', 'OPENCV_INCLUDE_DIR', 'OPENCV_LIB_DIR'];
/**
 * arguments data
 */
exports.ALLARGS = {
    version: { arg: 'version', conf: 'autoBuildOpencvVersion', env: 'OPENCV4NODEJS_AUTOBUILD_OPENCV_VERSION', isBool: false, doc: 'OpenCV version' },
    flags: { arg: 'flags', conf: 'autoBuildFlags', env: 'OPENCV4NODEJS_AUTOBUILD_FLAGS', isBool: false, doc: 'OpenCV cMake Build flags' },
    root: { arg: 'root', conf: 'rootcwd', env: 'INIT_CWD', isBool: false, doc: 'OpenCV-build root directory (deprecated)' },
    buildRoot: { arg: 'buildRoot', conf: 'buildRoot', env: 'OPENCV_BUILD_ROOT', isBool: false, doc: 'OpenCV build directory' },
    cuda: { arg: 'cuda', conf: 'autoBuildBuildCuda', env: 'OPENCV4NODEJS_BUILD_CUDA', isBool: true, doc: 'Enable cuda in OpenCV build' },
    nocontrib: { arg: 'nocontrib', conf: 'autoBuildWithoutContrib', env: 'OPENCV4NODEJS_AUTOBUILD_WITHOUT_CONTRIB', isBool: true, doc: 'Do not compile Contrib modules' },
    nobuild: { arg: 'nobuild', conf: 'disableAutoBuild', env: 'OPENCV4NODEJS_DISABLE_AUTOBUILD', isBool: true, doc: 'Do build OpenCV' },
    OPENCV_INCLUDE_DIR: { arg: 'incDir', conf: 'opencvIncludeDir', env: 'OPENCV_INCLUDE_DIR', isBool: false, doc: 'OpenCV include directory' },
    OPENCV_LIB_DIR: { arg: 'libDir', conf: 'opencvLibDir', env: 'OPENCV_LIB_DIR', isBool: false, doc: 'OpenCV library directory' },
    OPENCV_BIN_DIR: { arg: 'binDir', conf: 'opencvBinDir', env: 'OPENCV_BIN_DIR', isBool: false, doc: 'OpenCV bin directory' },
    keepsources: { arg: 'keepsources', conf: 'keepsources', isBool: true, doc: 'Keepsources OpenCV source after build' },
    dryRun: { arg: 'dry-run', conf: 'dry-run', isBool: true, doc: 'Display command line use to build library' },
    gitCache: { arg: 'git-cache', conf: 'git-cache', env: 'OPENCV_GIT_CACHE', isBool: true, doc: 'Reduce Bandwide usage, by keeping a local git souce un the buildRoot' },
};
/**
 * generate help message
 * @returns help message as text with colors
 */
const genHelp = () => {
    return Object.values(exports.ALLARGS).map(a => {
        const name = `--${a.arg}${!a.isBool ? ' <value>' : ''}`;
        const envWay = a.env ? ` (${a.env} env variable)` : '';
        return `   ${name.padEnd(20)} ${a.doc.padEnd(40)}${envWay}`;
    }).join('\n');
};
exports.genHelp = genHelp;
/**
 * A basic args parser
 * @param args cmd lines args
 * @returns and openCVBuildEnvParams object containing an extra object with all unknown args
 */
const args2Option = (args) => {
    let out = { extra: {} };
    for (let i = 0; i < args.length; i++) {
        let arg = args[i];
        if (arg.startsWith('--')) {
            arg = arg.substring(2);
        }
        else if (arg.startsWith('-')) {
            arg = arg.substring(1);
        }
        else {
            continue;
        }
        const p = arg.indexOf('=');
        const name = ((p === -1) ? arg : arg.substring(0, p));
        const info = exports.ALLARGS[name];
        if (!info) {
            // keep unknown args in extras
            const val = (p > 0) ? arg.substring(p + 1) : (i + 1 < args.length) ? args[i + 1] : '1';
            if (out.extra)
                out.extra[name] = val;
            continue;
        }
        if (info.isBool) {
            out[info.conf] = true;
            continue;
        }
        const val = (p > 0) ? arg.substring(p + 1) : args[++i];
        if (val)
            out[info.conf] = val;
    }
    // encvIncludeDir?: string;
    return out;
};
exports.args2Option = args2Option;
/**
 * All available module fron openCV 4.5.5
 */
exports.ALL_OPENCV_MODULES = ['apps', 'aruco', 'bgsegm', 'bioinspired', 'calib3d', 'ccalib',
    'core', 'datasets', 'dnn', 'dnn_objdetect', 'dpm', 'features2d', 'flann', 'fuzzy',
    'gapi', 'hfs', 'highgui', 'img_hash', 'imgcodecs', 'imgproc', 'java_bindings_generator',
    'js', 'js_bindings_generator', 'line_descriptor', 'ml', 'objc_bindings_generator',
    'objdetect', 'optflow', 'phase_unwrapping', 'photo', 'python3', 'python_bindings_generator',
    'python_tests', 'reg', 'rgbd', 'saliency', 'shape', 'stereo', 'stitching', 'structured_light',
    'superres', 'surface_matching', 'ts', 'video', 'videoio', 'wechat_qrcode', 'world',
    'xobjdetect', 'xphoto'];
class OpenCVBuildEnv {
    constructor(opts = {}) {
        this.opts = opts;
        this.buildWithCuda = false;
        this.isWithoutContrib = false;
        this.isAutoBuildDisabled = false;
        this.keepsources = false;
        this.dryRun = false;
        this.gitCache = false;
        _OpenCVBuildEnv_packageEnv.set(this, {});
        _OpenCVBuildEnv_ready.set(this, false);
        /** default module build list */
        _OpenCVBuildEnv_enabledModules.set(this, new Set(['calib3d', 'core', 'dnn', 'features2d', 'flann', 'gapi', 'highgui', 'imgcodecs', 'imgproc',
            'ml', 'objdetect', 'photo', 'python_tests', 'video', 'videoio']));
        const DEFAULT_OPENCV_VERSION = '4.5.5';
        this.prebuild = opts.prebuild;
        this._platform = process.platform;
        this.packageRoot = opts.rootcwd || process.env.INIT_CWD || process.cwd();
        this.buildRoot = opts.buildRoot || process.env.OPENCV_BUILD_ROOT || path_1.default.join(__dirname, '..');
        if (this.buildRoot[0] === '~') {
            this.buildRoot = path_1.default.join(os_1.default.homedir(), this.buildRoot.slice(1));
        }
        // get project Root path to looks for package.json for opencv4nodejs section
        try {
            __classPrivateFieldSet(this, _OpenCVBuildEnv_packageEnv, this.readEnvsFromPackageJson(), "f");
        }
        catch (err) {
            npmlog_1.default.error('applyEnvsFromPackageJson', 'failed to parse package.json:');
            npmlog_1.default.error('applyEnvsFromPackageJson', err);
        }
        // try to use previouse build
        this.no_autobuild = this.resolveValue(exports.ALLARGS.nobuild);
        if (!this.no_autobuild && opts.prebuild) {
            const builds = this.listBuild();
            if (!builds.length) {
                throw Error(`No build found in ${this.rootDir} you should launch opencv-build-npm once`);
            }
            if (builds.length > 1) {
                switch (opts.prebuild) {
                    case 'latestBuild':
                        builds.sort((a, b) => b.date.getTime() - a.date.getTime());
                        break;
                    case 'latestVersion':
                        builds.sort((a, b) => b.dir.localeCompare(a.dir));
                        break;
                    case 'oldestBuild':
                        builds.sort((a, b) => a.date.getTime() - b.date.getTime());
                        break;
                    case 'oldestVersion':
                        builds.sort((a, b) => a.dir.localeCompare(b.dir));
                        break;
                }
            }
            // load envthe prevuious build
            const autoBuildFile = this.readAutoBuildFile2(builds[0].autobuild);
            if (!autoBuildFile)
                throw Error(`failed to read build info from ${builds[0].autobuild}`);
            let flagStr = autoBuildFile.env.autoBuildFlags;
            // merge -DBUILD_opencv_ to internal BUILD_opencv_ manager
            if (flagStr) {
                let flags = flagStr.split(' ');
                flags.filter(flag => {
                    if (flag.startsWith('-DBUILD_opencv_')) {
                        let [mod, activated] = flag.substring(15).split('=');
                        activated = activated.toUpperCase();
                        if (activated === 'ON' || activated === '1') {
                            __classPrivateFieldGet(this, _OpenCVBuildEnv_enabledModules, "f").add(mod);
                        }
                        else if (activated === 'OFF' || activated === '0') {
                            __classPrivateFieldGet(this, _OpenCVBuildEnv_enabledModules, "f").delete(mod);
                        }
                        return false;
                    }
                    return true;
                });
            }
            this.autoBuildFlags = flagStr;
            this.buildWithCuda = autoBuildFile.env.buildWithCuda;
            this.isAutoBuildDisabled = autoBuildFile.env.isAutoBuildDisabled;
            this.isWithoutContrib = autoBuildFile.env.isWithoutContrib;
            this.opencvVersion = autoBuildFile.env.opencvVersion;
            this.buildRoot = autoBuildFile.env.buildRoot;
            if (!this.opencvVersion) {
                throw Error(`autobuild file is corrupted, opencvVersion is missing in ${builds[0].autobuild}`);
            }
            process.env.OPENCV_BIN_DIR = autoBuildFile.env.OPENCV_BIN_DIR;
            process.env.OPENCV_INCLUDE_DIR = autoBuildFile.env.OPENCV_INCLUDE_DIR;
            process.env.OPENCV_LIB_DIR = autoBuildFile.env.OPENCV_LIB_DIR;
            return;
        }
        // try to build a new openCV or use a prebuilt one
        if (this.no_autobuild) {
            this.opencvVersion = '0.0.0';
        }
        else {
            this.opencvVersion = this.resolveValue(exports.ALLARGS.version);
            if (!this.opencvVersion) {
                this.opencvVersion = DEFAULT_OPENCV_VERSION;
                npmlog_1.default.info('init', `no openCV version given using default verison ${(0, utils_1.formatNumber)(DEFAULT_OPENCV_VERSION)}`);
            }
            else {
                npmlog_1.default.info('init', `using openCV verison ${(0, utils_1.formatNumber)(this.opencvVersion)}`);
            }
            if (process.env.INIT_CWD) {
                npmlog_1.default.info('init', `${(0, utils_1.highlight)("INIT_CWD")} is defined overwriting root path to ${(0, utils_1.highlight)(process.env.INIT_CWD)}`);
            }
            // ensure that OpenCV workdir exists
            if (!fs_1.default.existsSync(this.buildRoot)) {
                fs_1.default.mkdirSync(this.buildRoot);
                if (!fs_1.default.existsSync(this.buildRoot)) {
                    throw new Error(`${this.buildRoot} can not be create`);
                }
            }
        }
        // import configuration from package.json
        const envKeys = Object.keys(__classPrivateFieldGet(this, _OpenCVBuildEnv_packageEnv, "f"));
        if (envKeys.length) {
            // print all imported variables
            npmlog_1.default.info('applyEnvsFromPackageJson', 'the following opencv4nodejs environment variables are set in the package.json:');
            envKeys.forEach((key) => npmlog_1.default.info('applyEnvsFromPackageJson', `${(0, utils_1.highlight)(key)}: ${(0, utils_1.formatNumber)(__classPrivateFieldGet(this, _OpenCVBuildEnv_packageEnv, "f")[key] || '')}`));
        }
        this.autoBuildFlags = this.resolveValue(exports.ALLARGS.flags);
        this.buildWithCuda = !!this.resolveValue(exports.ALLARGS.cuda);
        this.isWithoutContrib = !!this.resolveValue(exports.ALLARGS.nocontrib);
        this.isAutoBuildDisabled = !!this.resolveValue(exports.ALLARGS.nobuild);
        this.keepsources = !!this.resolveValue(exports.ALLARGS.keepsources);
        this.dryRun = !!this.resolveValue(exports.ALLARGS.dryRun);
        this.gitCache = !!this.resolveValue(exports.ALLARGS.gitCache);
    }
    resolveValue(info) {
        if (info.conf in this.opts) {
            if (info.isBool) {
                return this.opts[info.conf] ? '1' : '';
            }
            else
                return this.opts[info.conf] || '';
        }
        else {
            if (__classPrivateFieldGet(this, _OpenCVBuildEnv_packageEnv, "f") && __classPrivateFieldGet(this, _OpenCVBuildEnv_packageEnv, "f")[info.conf]) {
                return __classPrivateFieldGet(this, _OpenCVBuildEnv_packageEnv, "f")[info.conf] || '';
            }
            else {
                return process.env[info.env] || '';
            }
        }
    }
    /**
     * complet initialisation.
     */
    getReady() {
        if (__classPrivateFieldGet(this, _OpenCVBuildEnv_ready, "f"))
            return;
        __classPrivateFieldSet(this, _OpenCVBuildEnv_ready, true, "f");
        for (const varname of exports.OPENCV_PATHS_ENV) {
            const value = this.resolveValue(exports.ALLARGS[varname]);
            if (value && process.env[varname] !== value) {
                process.env[varname] = value;
            }
        }
        if (this.no_autobuild) {
            for (const varname of exports.OPENCV_PATHS_ENV) {
                const value = process.env[varname];
                if (!value) {
                    throw new Error(`${varname} must be define if can not be create nobuild / disableAutoBuild / OPENCV4NODEJS_DISABLE_AUTOBUILD is set`);
                }
                let stats;
                try {
                    stats = fs_1.default.statSync(value);
                }
                catch (e) {
                    throw new Error(`${varname} is set to non existing "${value}"`);
                }
                if (!stats.isDirectory()) {
                    throw new Error(`${varname} is set to "${value}", that should be a directory`);
                }
            }
        }
    }
    get enabledModules() {
        return [...__classPrivateFieldGet(this, _OpenCVBuildEnv_enabledModules, "f")];
    }
    enableModule(mod) {
        if (__classPrivateFieldGet(this, _OpenCVBuildEnv_ready, "f"))
            throw Error('No mode modules change can be done after initialisation done.');
        __classPrivateFieldGet(this, _OpenCVBuildEnv_enabledModules, "f").add(mod);
    }
    disableModule(mod) {
        if (__classPrivateFieldGet(this, _OpenCVBuildEnv_ready, "f"))
            throw Error('No mode modules change can be done after initialisation done.');
        __classPrivateFieldGet(this, _OpenCVBuildEnv_enabledModules, "f").delete(mod);
    }
    /**
     * @returns return cmake flags like: -DBUILD_opencv_modules=ON ...
     */
    getCmakeBuildFlags() {
        const out = [];
        for (const mod of exports.ALL_OPENCV_MODULES) {
            let arg = `-DBUILD_opencv_${mod}=`;
            arg += __classPrivateFieldGet(this, _OpenCVBuildEnv_enabledModules, "f").has(mod) ? 'ON' : 'OFF';
            out.push(arg);
        }
        return out;
    }
    // if version < 4.5.6 ffmpeg 5 not compatible
    // https://stackoverflow.com/questions/71070080/building-opencv-from-source-in-mac-m1
    // brew install ffmpeg@4
    // brew unlink ffmpeg
    // brew link ffmpeg@4
    getSharedCmakeFlags() {
        let cMakeflags = [
            `-DCMAKE_INSTALL_PREFIX=${this.opencvBuild}`,
            '-DCMAKE_BUILD_TYPE=Release',
            '-DBUILD_EXAMPLES=OFF',
            '-DBUILD_DOCS=OFF',
            '-DBUILD_TESTS=OFF',
            '-DBUILD_PERF_TESTS=OFF',
            '-DBUILD_JAVA=OFF',
            '-DBUILD_ZLIB=OFF',
            '-DCUDA_NVCC_FLAGS=--expt-relaxed-constexpr',
            '-DWITH_VTK=OFF'
        ];
        if (!this.isWithoutContrib)
            cMakeflags.push('-DOPENCV_ENABLE_NONFREE=ON', `-DOPENCV_EXTRA_MODULES_PATH=${this.opencvContribModules}`);
        cMakeflags.push(...this.getCongiguredCmakeFlags());
        return cMakeflags;
        // .cMakeflags.push('-DCMAKE_SYSTEM_PROCESSOR=arm64', '-DCMAKE_OSX_ARCHITECTURES=arm64');
    }
    getCongiguredCmakeFlags() {
        let cMakeflags = [];
        if (this.buildWithCuda && (0, utils_1.isCudaAvailable)()) {
            // log.info('install', 'Adding CUDA flags...');
            // this.enabledModules.delete('cudacodec');// video codec (NVCUVID) is deprecated in cuda 10, so don't add it
            cMakeflags.push('-DWITH_CUDA=ON', '-DCUDA_FAST_MATH=ON' /* optional */, '-DWITH_CUBLAS=ON' /* optional */);
        }
        cMakeflags.push(...this.getCmakeBuildFlags());
        // add user added flags
        if (this.autoBuildFlags && typeof (this.autoBuildFlags) === 'string' && this.autoBuildFlags.length) {
            // log.silly('install', 'using flags from OPENCV4NODEJS_AUTOBUILD_FLAGS:', this.autoBuildFlags)
            cMakeflags.push(...this.autoBuildFlags.split(' '));
        }
        return cMakeflags;
    }
    dumpEnv() {
        return {
            opencvVersion: this.opencvVersion,
            buildWithCuda: this.buildWithCuda,
            isWithoutContrib: this.isWithoutContrib,
            isAutoBuildDisabled: this.isAutoBuildDisabled,
            autoBuildFlags: this.autoBuildFlags,
            buildRoot: this.buildRoot,
            OPENCV_INCLUDE_DIR: process.env.OPENCV_INCLUDE_DIR || '',
            OPENCV_LIB_DIR: process.env.OPENCV_LIB_DIR || '',
            OPENCV_BIN_DIR: process.env.OPENCV_BIN_DIR || '',
        };
    }
    /**
     * extract opencv4nodejs section from package.json if available
     */
    parsePackageJson() {
        // const absPath = path.resolve(this.rootcwd, 'package.json')
        const absPath = path_1.default.resolve(process.cwd(), 'package.json');
        if (!fs_1.default.existsSync(absPath)) {
            if (!this.prebuild)
                npmlog_1.default.info('config', `No file ${(0, utils_1.highlight)("%s")} found for opencv4nodejs import`, absPath);
            return null;
        }
        const data = JSON.parse(fs_1.default.readFileSync(absPath).toString());
        return { file: absPath, data };
    }
    numberOfCoresAvailable() { return os_1.default.cpus().length; }
    /**
     * get opencv4nodejs section from package.json if available
     * @returns opencv4nodejs customs
     */
    readEnvsFromPackageJson() {
        const rootPackageJSON = this.parsePackageJson();
        if (!rootPackageJSON) {
            return {};
        }
        if (!rootPackageJSON.data) {
            npmlog_1.default.info('config', `looking for opencv4nodejs option from ${(0, utils_1.highlight)("%s")}`, rootPackageJSON.file);
            return {};
        }
        if (!rootPackageJSON.data.opencv4nodejs) {
            npmlog_1.default.info('config', `no opencv4nodejs section found in ${(0, utils_1.highlight)('%s')}`, rootPackageJSON.file);
            return {};
        }
        npmlog_1.default.info('config', `found opencv4nodejs section in ${(0, utils_1.highlight)('%s')}`, rootPackageJSON.file);
        return rootPackageJSON.data.opencv4nodejs;
    }
    /**
     * openCV uniq version prostfix, used to avoid build path colision.
     */
    get optHash() {
        let optArgs = this.getCongiguredCmakeFlags().join(' ');
        // if (this.autoBuildFlags) 
        //     optArgs += ' ' + this.autoBuildFlags;
        if (this.buildWithCuda)
            optArgs += 'cuda';
        if (this.isWithoutContrib)
            optArgs += 'noContrib';
        if (optArgs) {
            optArgs = '-' + crypto_1.default.createHash('md5').update(optArgs).digest('hex').substring(0, 5);
        }
        return optArgs;
    }
    listBuild() {
        const rootDir = this.rootDir;
        const versions = fs_1.default.readdirSync(rootDir)
            .filter(n => n.startsWith('opencv-'))
            .map((n) => ({ autobuild: path_1.default.join(rootDir, n, 'auto-build.json'), dir: n }))
            .filter((n) => fs_1.default.existsSync(n.autobuild))
            .map(({ autobuild, dir }) => ({ autobuild, dir, date: fs_1.default.statSync(autobuild).mtime }));
        //fs.existsSync(path.join(rootDir, n, 'auto-build.json')));
        return versions;
    }
    get platform() {
        return this._platform;
    }
    get isWin() {
        return this.platform === 'win32';
    }
    get rootDir() {
        // const __filename = fileURLToPath(import.meta.url);
        // const __dirname = dirname(__filename);
        // return path.resolve(__dirname, '../');
        return this.buildRoot;
    }
    get opencvRoot() {
        return path_1.default.join(this.rootDir, `opencv-${this.opencvVersion}${this.optHash}`);
    }
    get opencvGitCache() {
        return path_1.default.join(this.rootDir, 'opencvGit');
    }
    get opencvContribGitCache() {
        return path_1.default.join(this.rootDir, 'opencv_contribGit');
    }
    get opencvSrc() {
        return path_1.default.join(this.opencvRoot, 'opencv');
    }
    get opencvContribSrc() {
        return path_1.default.join(this.opencvRoot, 'opencv_contrib');
    }
    get opencvContribModules() {
        return path_1.default.join(this.opencvContribSrc, 'modules');
    }
    get opencvBuild() {
        return path_1.default.join(this.opencvRoot, 'build');
    }
    get opencvInclude() {
        return path_1.default.join(this.opencvBuild, 'include');
    }
    get opencv4Include() {
        this.getReady();
        if (process.env.OPENCV_INCLUDE_DIR)
            return process.env.OPENCV_INCLUDE_DIR;
        return path_1.default.join(this.opencvInclude, 'opencv4');
    }
    get opencvIncludeDir() {
        this.getReady();
        return process.env.OPENCV_INCLUDE_DIR || '';
    }
    get opencvLibDir() {
        this.getReady();
        if (process.env.OPENCV_LIB_DIR)
            return process.env.OPENCV_LIB_DIR;
        return this.isWin ? path_1.default.join(this.opencvBuild, 'lib/Release') : path_1.default.join(this.opencvBuild, 'lib');
    }
    get opencvBinDir() {
        this.getReady();
        if (process.env.OPENCV_BIN_DIR)
            return process.env.OPENCV_BIN_DIR;
        return this.isWin ? path_1.default.join(this.opencvBuild, 'bin/Release') : path_1.default.join(this.opencvBuild, 'bin');
    }
    get autoBuildFile() {
        return path_1.default.join(this.opencvRoot, 'auto-build.json');
    }
    readAutoBuildFile() {
        return this.readAutoBuildFile2(this.autoBuildFile);
    }
    readAutoBuildFile2(autoBuildFile) {
        try {
            const fileExists = fs_1.default.existsSync(autoBuildFile);
            if (fileExists) {
                const autoBuildFileData = JSON.parse(fs_1.default.readFileSync(autoBuildFile).toString());
                if (!autoBuildFileData.opencvVersion || !('autoBuildFlags' in autoBuildFileData) || !Array.isArray(autoBuildFileData.modules)) {
                    throw new Error('auto-build.json has invalid contents');
                }
                return autoBuildFileData;
            }
            npmlog_1.default.info('readAutoBuildFile', 'file does not exists: %s', autoBuildFile);
        }
        catch (err) {
            npmlog_1.default.error('readAutoBuildFile', 'failed to read auto-build.json from: %s, with error: %s', autoBuildFile, err.toString());
        }
        return undefined;
    }
}
exports.OpenCVBuildEnv = OpenCVBuildEnv;
_OpenCVBuildEnv_packageEnv = new WeakMap(), _OpenCVBuildEnv_ready = new WeakMap(), _OpenCVBuildEnv_enabledModules = new WeakMap();
//# sourceMappingURL=BuildEnv.js.map